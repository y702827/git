Perf stuff:
  * New style
    * diffcore_rename_extended() also takes:
      * relevant_sources: strmap (acting as set)
      * relevant_targets: strmap (acting as set)
      * dirs_removed:     strmap (acting as set)
    * diffcore_rename() calls diffcore_rename_extended() with some NULLs
    * collect_merge_info_callback():
      * generate full set of pairs early
      * avoid including path in relevant_sources by partial capitulation rules
      * pass NULL for relevant_targets for now (useful later for --follow)
      * record removed dirs in dirs_removed
    * diffcore_rename_extended() changes:
      * detect exact renames, as now
      * detect basenames:
        * limit to relevant_(sources|targets)
        * continue only detecting if a one-to-one match
	* if there are multiple renames (Makefile, .gitignore, hwmon.c), and
	  if dirs_removed is not NULL, add a follow-up
	* follow-up (new function?):
	  * look through the exact renames of files that started in the exact
	    same directory as the file source.  Generate mapping of
	    olddir -> newdir, keeping counts of number of files that renamed
	    directories in that fashion.  Keep track of the biggest.  Then
	    take the one with the most renames, and try applying that dir
	    rename to the path.  If you get a valid target path, check
	    similarity.
    * Note that optimization 4 (known renames from before):
      * goes in merge-ort, not diffcore-rename
      * records renames together with two side trees and target tree
      * checks on next run if merge base is one of two side trees, and one of
        two sides in the target tree.  Only applies in this case.
      * automatically applies the renames on the given side, removing the
        potential pairs before calling in to diffcore_rename[_extended]()
      * may be able to use this optimization to allow more cases of trivial
        tree merges.  (Can't resolve one side matches with trees if there
        are any deletes anywhere normally, but if those deletes are all for
        known renames and those renames target outside the given tree, then
        we can do the trivial tree merge.)
    * Unneeded:
      * basename_same()
      * record_rename()
      * detect_exact_renames()
      * diff_queue_path()??
      * detect_renames_by_basename()
    * Other notes:
      * Can undo complication in collect_merge_info_callback() for side match
        (No need to setup_path_info() for cases 1.A or 2.A anymore)
      * mode check in collect_rename_info() isn't necessary anymore, but
        find_basename_matches() should check for modes like
	estimate_similarity() does
      * generate_pairs() can probably be simplified
      * merge_start() and reset_maps() can be simplified

  * partial capitulation
    * rename steps
      * if partial capitulation suggests no rename sources/dests, exit early
      * otherwise, look in rename sources/dests for exact renames
      * look in rename sources/dests for basename sets; use new get_diffpairs()
      * if remaining rename sources and dests, call get_diffpairs()
    * Extra data to gather
      * - 3 sets of hash -> string mappings (for exact renames)
      * - 4? sets of strmap->string_list mappings (for basenames->list of names)
    * Other notes:
      * get_diffpairs(); like current, but can work on a smaller set of paths.
        In particular, turn off verbose feedback when called on set of 14
	basenames.
  * Partial subtree elimination (already done when all-sides match, but also:)
    1. push one-sided tree-match cases onto a stack
    2. after all trees walked except one-sided tree-match cases:
      2a. if no file deletions, resolve one-sided tree-match without recursing
      2b. if file deletions, recurse into one-sided tree-match cases
    3. do normal rename detection

Perf command example:
  * hyperfine --warmup 1 -c 'git reset --hard' 'git cherry-pick --no-commit 4413405f931e'

* Overall plan
  X Renames
  X Write the talk
  X Directory renames
  / Implement basic perf ideas
  * Additional Perf testing
  * Output
  * Path conflict files
  * Check the "Stuff to not forget"
  / Make sure the API is clean/clear
  * Cleanup of FIXMEs
  * Double check data structures; is anything unnecessary or needing a rename?
  * Correctness testing against lotsa repos
  * Default to histogram diff
  * Features like --remerge-diff
  * Diff3 improvements

Path_conflict files:
  * Mode conflict (Directory/Non-Executable/Executable/Submodule/Symlink)
  * Modify/delete (or rename/delete)
  * Rename/rename(1to2)
  * Binary-ish conflict
    * ISREG, but binary
    * symlink edit/edit
    * submodule edit/edit in non-fast-forward ways

  * Maybe also:
    * add/add, rename/add, rename/rename(2to1)
    * rename/add/delete
    * take an add/add onto rename/rename(1to2) or delete/delete onto 2to1

* Stuff to not forget:
  * Perf idea: exact matches in diffcore_rename() is quadratic!!  Whoops!
  * Perf idea: make sure partial capitulation (source match) does not defeat
    either exact renames or dimensionality reduction, since those two can
    reduce the number of both potenial rename sources AND destinations.
  * Perf idea: can trivial tree merge (O matches A implies take B when all
    three are trees) if no parent trees differed outside of directory leading
    to this directory and sibling trees do not differ.  However, it means that
    we can't recurse into entries as we go, we have to first check all the
    tree entries for the toplevel directory, verify that only one differs,
    then can use the trick.
  * Perf Idea: should be able to memoize values in check_dir_renamed()
  * Perf Idea: hashmap->khash (see 8b2f8cbcb1 ("oidset: use khash", 2018-10-04))
  * Perf Idea: default check-upstream-for-sameness to off

  * Path conflict files; also, multiple auxiliary files to add (e.g. for
    mode conflict at a, need a~HEAD, a~MERGE_HEAD, a.path_conflict, or for
    D/F conflict at a, need a~HEAD and a.path_conflict in addition to dir a/)
  * conflict messages need to be printed, usually
  * Normalization code from merge-recursive.c -- modify/delete might actually
    be a not-modified/delete (but possibly move from merge_3way() to
    collect_merge_info_callback())
  * FIXMEs in checkout() (and elsewhere)
  * Do an additional rename-like pass when ignore_case, searching for file
    collisions (or can I just rely on unpack_trees reporting errors?)
  * Avoid string_list_lookup() & string_list_insert() in merge-ort
  * collect_merge_info: when directories match but I still have to recurse,
    I could save off that info and then not have to compare sub-files and
    sub-directories within that mask.  (e.g. if base:foo matches head:foo, but
    merge:foo is different, there's no need to compare base:foo/bar and
    head:foo/bar when I recurse into the foo directory)
  * In collect_merge_info_callback, I cannot usually do trivial tree merge when
    one tree matches base if the other side is a tree, but I CAN do that when
    the tree in question is the toplevel tree, which happens when rebasing empty
    commits and such.  That also avoids rename detection...
  * diffcore-rename:
    * Avoid MOVE_ARRAY in diffcore-rename.c; use strmap instead

  * Perf note, avoid re-doing work:
    * traverse_tree/read_tree_recursive count:
      * merge-recursive:
        * unpack_trees (1), diff-for-renames (2), get_files_dirs (2),
	  get_tree_entry_if_blob (3 * 2 * unmerged entries)
      * merge-ort:
        * direct call (1), unpack_trees (1)
    * computing of mode/oid null, and which sides match.  merge-recursive
      duplicates unpack_trees logic, where merge-ort saves it off.
  * Perf note, avoiding doing unnecessary work:
    * Removal of unnecessary drop_cache and re-read of cache in
      non-recursive case

* Important stuff to call out for reviewers to double-check:
  * write_tree() -- yet another place trees are written (builtin/mktree,
    fast-import, cache-tree); is that okay?
  * checkout() (overwrite_ignore? refresh_index?)
  * record_unmerged_index_entries() (cache-tree invalidation?
    state flags correct?  should I avoid ADD_CACHE_JUST_APPEND if
    strmap_size(unmerged) < O(log(opt->repo->index->cache_nr)/3) ?



* Old notes on renames:
  * Determine renames
    * get normal renames
    * get directory renames
    * dir renames merely modify normal renames
  * Rename related information:
    * source path has at least one and at most two stages associated with it
    * dest path has at least one and at most two stages associated with it
    * dest path cannot have a base stage
    * source path cannot have the stage corresponding to side of history renamed
    * 1 stage each side: delete/rename (or rename/rename(1to2))
    * 2 stages in source, 1 in dest: typical rename
    * 1 stage in source, 2 in dest: delete/rename/add conflict (or r/r(1to2)/a)
    * 2 stages each side: rename/add
    * (Note that add can be replaced by rename(2to1), just as rename(1to2) can
       replace a delete)
  * Need supplemental information for marking things as conflicted even if not
    due to contents (clean dir renames are conflicts by default...)
  * Modify struct rename and get_renames():
    * Do not use insert_stage_data()
    * Note the sidemask for the renames
    * Have the second call to get_renames() append to same rename string_list
    * Call string_list_append(), NOT string_list_insert; sort at end
  * process_renames:
    * Combine two lists of renames into one and sort
      * But make sure there is a sidemask recorded before doing so
      * This puts rename/rename(1to2) cases as adjacent entries
    * Loop over each rename pair
      * If next entry has same source name, then it's rename/rename(1to2)
        * FIXME: special handling...
      * Mark source path as resolved/unused (is_null)
      * If only 1 stage source side:
        * Copy base stage from source to dest
	* Add this rename to a *map* (by source name) for later post-processing
      * If two stages source side, and one stage dest side:
        * Copy stages from source side to dest side
      * If two stages source side, and two stages dest side:
        * Three-way content merge two source stages with appropriate dest stage
	* Replace appropriate dest stage with three-way merged content
