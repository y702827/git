Current count: 32

* Avoid small wasted effort (3)
  * avoid unnecessary discard and re-read of cache [b]
  * avoid checking index matches HEAD with every merge; do it at start of rebase
  * avoid working tree and index updates until the end
* Work with less data (5)
  * fewer tree-walks [a]
  * trivial tree merges, when all three trees match
  * trivial tree merges, when one side matches (if renames cached or not needed)
    * trivial tree merges for new trees
    * trivial tree merges even when renames not cached and needed
* Directory rename related (4)
  * track dirs added/removed and only do directory rename detection for them
  * only do directory rename detection when dirmask is 3 or 5 (not when it is 1)
  * caching directory rename detection from previous pick
  * If exact renames provide enough info for directory rename detection, avoid
    detecting renames for other paths within directory unless needed for content
    merge
* Basic rename detection algorithm (7)
  * Don't find match better than exact
  * Don't do rename detection for non-relevant paths (other side didn't change),
    unless needed due to directory rename detection
    * ...but we can use dir_rename_mask to allow it in a lot more cases
  * Matchup files based on basename
    * when non-unique (e.g. Makefile, .gitignore), guide guess about which
      to compare to based on guess at directory renames via exact renames
  * Apply exact matches first, then basename matches on remaining set
  * Remember renames (& deletes) for subsequent sequencer operations
* Optimize diffcore_rename logic (6)
  * Filter rename_src list
  * Short-circuit diffcore_rename if no sources (in addition to if no targets)
  * Avoid calling diffcore_rename if no pairs or no relevant sources
  * Only guide basename guessing for relevant_sources and relevant_targets
  * simplify and accelerate register_rename_src()
  * accelerate rename_dst setup
* Misc (7)
  * avoid O(N^2) index insertion/deletion
  * avoid reading/writing rebase metadata until conflict or completion
  * replace string_list_df_name_compare with faster/clearer alternative
  * drop merged_info size by 8 bytes
  * Create a smarter strmap_partial_clear() by adding a hashmap_partial_clear
  * avoid recomparing hashes (use match_masks)
  * use memory pools


Unimplemented optimizations (6):
  * avoid checking unmerged_index() in checkout() (& maybe refresh_index?)
  * hashmap -> khash (see commit 8b2f8cbcb1 ("oidset: use khash", 2018-10-04))
  * default allocation sizes for strmaps/pairs (e.g. 2*index entries for path)
  * dir rename:
    * reuse check_dir_renamed() results from compute_collisions()
      in collect_renames() instead of calling it again for all pairs
    * memoize check_dir_renamed() [augment dir_renames with non-renames]
  * avoid finding basename-directed renames for paths that aren't
    content-relevant when exact renames provide enough information to determine
    directory renames

Rejected optimizations (5):
  * Turning off asserts (saves about a third of a percent of runtime)
  * Switching back from histogram to myers diff (saves about a percent)
  * Running under jemalloc (saved a percent in the past, though)
  * Changing compiler flags (just used `make DEVELOPER=1`)
  * Parallelization


[a] Perf note, avoid re-doing work:
    * traverse_tree/read_tree_recursive count:
      * merge-recursive:
        * unpack_trees (1), diff-for-renames (2), get_files_dirs (2),
          get_tree_entry_if_blob (3 * 2 * unmerged entries)
      * merge-ort:
        * direct call (1), unpack_trees (1)
    * computing of mode/oid null, and which sides match.  merge-recursive
      duplicates unpack_trees logic, where merge-ort saves it off.
[b] Perf note, avoiding doing unnecessary work:
    * Removal of unnecessary drop_cache and re-read of cache in
      non-recursive case
