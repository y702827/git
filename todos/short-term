* Performance Idea:
  * Keep a list of semi_relevant_sources too, for cases where we are detecting
    renames solely for the purpose of directory rename detection.
    * If a majority of paths under a directory are sufficient to
      determine the directory rename, we don't need to do inexact
      rename detection for semi_relevant_sources.
      * May want to check before and after basename matching (might be able to
        skip not just exhaustive searching but also basename matching).
      * Do I want to change the diffcore_rename API to allow individual stages
        to be executed?
    * basename matching already has pseudo directory rename detection logic in
      it, so this will just extend it a little
    * May need to modify how cached_pairs work (e.g. cached-as-delete-IF: the
      file on the other side remains unmodified)

*** Stuff to investigate:
  * If D/F conflict starts but match_mask on dir, does trivial resolve work?
    Even if the file was renamed into place and has content conflicts?
    resolve_trivial_directory_merge() seems to assume path is handled entirely.

Cleanup stuff:
  * MERGE_DIRECTORY_RENAMES_DEFAULT:
    * differs from MERGE_DIRECTORY_RENAMES_CONFLICT in that it will print an
      informational message about merge.directoryRenames.
      ("directory renames resulted in conflicts, if you'd rather they were
        just automatically resolved, set merge.directoryRenames to true")
  * Attr stuff:
    * pre-merge .gitattributes (assuming no attribute related info), then use
      result in merging other files
  * Output
    * Move diff_warn_rename_limit to join the code doing output of messages
    * print informational message about merge.directoryRenames at same time
    * Make path_msg assert that the path given exists in opt->priv->paths
  * Make merge/ directory
    * output-handling??
    * collect-merge-info
    * rename-detection
    * directory-rename-detection
    * process_entries
    * external-api ?
    * submodule-handling
    * content-merge-handling ? (
  * Make merge_switch_to_result() more versatile:
    * write output to console, to MERGE_OUT, both, or neither
    * update index and working directory, or index only.
      (working directory only makes no sense; at least need an in-memory index)
  * Why does conflict_info need a processed flag?  (merge-recursive holdover?)

Output stuff:
  * GIT_MERGE_VERBOSITY replacement with pipe-separated strings.
    GIT_MERGE_DEBUG? (also, change strings into bitfield upfront, so checks
    can be super cheap).  Then nuke VERBOSE_DEBUG.
    See: string_list_split
  * Write output not just to console but also to some file for user reference
    (much like .git/MERGE_HEAD and friends; maybe .git/MERGE_OUTPUT to go
     along with .git/MERGE_TREE?)

* Overall plan
  X Renames
  X Write the talk
  X Directory renames
  X Implement basic perf ideas
  X Additional Perf testing
  X Micro-optimizations
  X Output
    X write output to merge_result (in field named output, of course)
    X don't need the flush_output() thing
    X use strmap; path -> strbuf, for each path that has a message.
  X Look for test_expect_failure in merge tests of testsuite; fix some
  X Default to histogram diff
  * Path conflict files
  * Check the "Stuff to not forget"
  / Make sure the API is clean/clear
    * make merge-ort have its own options, maybe merge_inmemory_options?
    * make repo part of merge_options_internal?
  / Cleanup of FIXMEs
  * Double check data structures; is anything unnecessary or needing a rename?
  * Correctness testing against lotsa repos
  * Code coverage & valgrind testing
  * Features like --remerge-diff
  * Diff3 improvements

* Stuff to not forget:
  * Path conflict files; also, multiple auxiliary files to add (e.g. for
    mode conflict at a, need a~HEAD, a~MERGE_HEAD, a.path_conflict, or for
    D/F conflict at a, need a~HEAD and a.path_conflict in addition to dir a/)
  * FIXMEs in checkout() (and elsewhere)
  * Do an additional rename-like pass when ignore_case, searching for file
    collisions (or can I just rely on unpack_trees reporting errors?)
  * Avoid string_list_lookup() & string_list_insert() in merge-ort

Path_conflict files:
  * Mode conflict (Directory/Non-Executable/Executable/Submodule/Symlink)
  * Modify/delete (or rename/delete)
  * Rename/rename(1to2)
  * Binary-ish conflict
    * ISREG, but binary
    * symlink edit/edit
    * submodule edit/edit in non-fast-forward ways

  * Maybe also:
    * add/add, rename/add, rename/rename(2to1)
    * rename/add/delete
    * take an add/add onto rename/rename(1to2) or delete/delete onto 2to1

* Important stuff to call out for reviewers to double-check:
  * write_tree() -- yet another place trees are written (builtin/mktree,
    fast-import, cache-tree); is that okay?
  * checkout() (overwrite_ignore? refresh_index?)
  * record_unmerged_index_entries() (cache-tree invalidation?
    state flags correct?  should I avoid ADD_CACHE_JUST_APPEND if
    strmap_size(unmerged) < O(log(opt->repo->index->cache_nr)/3) ?

* Old notes on renames:
  * Rename related information:
    * 1 stage each side: delete/rename (or rename/rename(1to2))
    * 2 stages in source, 1 in dest: typical rename
    * 1 stage in source, 2 in dest: delete/rename/add conflict (or r/r(1to2)/a)
    * 2 stages each side: rename/add
    * (Note that add can be replaced by rename(2to1), just as rename(1to2) can
       replace a delete)

Feature work:
  * git show --remerge-diff[=<pick-commit>] ?  But if multiple commits to show,
    then this doesn't work so well.

* Demo-able stuff
  * Headline
    * "Fearless refactoring" (fast rename detection)
    * "Sparsify & partial clones -- going even further"
  * Behind the scenes
    * Perf
      * pgdev cherry-pick case
      * linux rebase case
      * partial clones improvements, in conjunction with sparse checkouts
    * Correctness
      * avoid false positive/false negative early abort
      * sparse-checkout improvement (avoid unnecessarily dirtying worktree, both
        due to SKIP_WORKTREE stuff, and due to rebase)
      * submodules
      * special cases -- D/F conflicts, etc.
  * new features coming:
    * cherry-pick to a branch which isn't checked out
    * local diff against automerge ('git diff --merge'?)
    * discovery of "evil" merges/cherry-picks/reverts
