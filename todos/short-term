Output stuff:
  * Am I missing cases where I need to add conflict messages?
  * test coverage (e.g. rename/rename 2->1 and nested content conflicts)
  * GIT_MERGE_VERBOSITY replacement with pipe-separated strings.
    GIT_MERGE_DEBUG? (also, change strings into bitfield upfront, so checks
    can be super cheap).  Then nuke VERBOSE_DEBUG.
  * Need to handle merge.directoryRenames = "conflict"
    * Need supplemental information for marking things as conflicted even if not
      due to contents (clean dir renames are conflicts by default...)
    * when processing directory renames, immediately call path_msg() and
      mark the file as path_conflict=1 ?
    * consider adding global (not path-specific) output capability too
      ("directory renames resulted in conflicts, if you'd rather they were
        just automatically resolved, set merge.directoryRenames to true")
  * Write output not just to console but also to some file for user reference
    (much like .git/MERGE_HEAD and friends; maybe .git/MERGE_OUTPUT to go
     along with .git/MERGE_TREE?)

Create a list of differences between recursive and ort:
* Overall plan
  X Renames
  X Write the talk
  X Directory renames
  X Implement basic perf ideas
  X Additional Perf testing
  X Micro-optimizations
  / Output
    X write output to merge_result (in field named output, of course)
    X don't need the flush_output() thing
    X use strmap; path -> strbuf, for each path that has a message.
  * Path conflict files
  * Check the "Stuff to not forget"
  / Make sure the API is clean/clear
    * make merge-ort have its own options, maybe merge_inmemory_options?
    * make repo part of merge_options_internal?
  * Cleanup of FIXMEs
  * Look for test_expect_failure in merge tests of testsuite; fix some
  * Double check data structures; is anything unnecessary or needing a rename?
  * Correctness testing against lotsa repos
  / Default to histogram diff...but less hackily
  * Features like --remerge-diff
  * Diff3 improvements

Path_conflict files:
  * Mode conflict (Directory/Non-Executable/Executable/Submodule/Symlink)
  * Modify/delete (or rename/delete)
  * Rename/rename(1to2)
  * Binary-ish conflict
    * ISREG, but binary
    * symlink edit/edit
    * submodule edit/edit in non-fast-forward ways

  * Maybe also:
    * add/add, rename/add, rename/rename(2to1)
    * rename/add/delete
    * take an add/add onto rename/rename(1to2) or delete/delete onto 2to1

* Stuff to not forget:
  * Path conflict files; also, multiple auxiliary files to add (e.g. for
    mode conflict at a, need a~HEAD, a~MERGE_HEAD, a.path_conflict, or for
    D/F conflict at a, need a~HEAD and a.path_conflict in addition to dir a/)
  * Normalization code from merge-recursive.c -- modify/delete might actually
    be a not-modified/delete (but possibly move from merge_3way() to
    collect_merge_info_callback())
  * FIXMEs in checkout() (and elsewhere)
  * Do an additional rename-like pass when ignore_case, searching for file
    collisions (or can I just rely on unpack_trees reporting errors?)
  * Avoid string_list_lookup() & string_list_insert() in merge-ort

* Important stuff to call out for reviewers to double-check:
  * write_tree() -- yet another place trees are written (builtin/mktree,
    fast-import, cache-tree); is that okay?
  * checkout() (overwrite_ignore? refresh_index?)
  * record_unmerged_index_entries() (cache-tree invalidation?
    state flags correct?  should I avoid ADD_CACHE_JUST_APPEND if
    strmap_size(unmerged) < O(log(opt->repo->index->cache_nr)/3) ?

* Old notes on renames:
  * Rename related information:
    * 1 stage each side: delete/rename (or rename/rename(1to2))
    * 2 stages in source, 1 in dest: typical rename
    * 1 stage in source, 2 in dest: delete/rename/add conflict (or r/r(1to2)/a)
    * 2 stages each side: rename/add
    * (Note that add can be replaced by rename(2to1), just as rename(1to2) can
       replace a delete)
