* Existing or latent bugs:
  * spurious directory rename split messages (dir_rename_count contains entries
    for directories that exist on both sides, and has e.g. 1 rename on each
    side).  Should prune keys of dir_rename_count down to those corresponding
    to those for which strintmap_get(dirs_removed[side], directory, 0) > 0.
    * However, this modifies testcases 12b and 12c of t6423 slightly.  12b was
      already modified for optimization purposes -- if no new files exist in the
      directory to be renamed, we won't bother detecting the rename.  Now, if
      there are no new files exist in the directory to be renamed, even if we
      detected the individual renames we'll ignore the directory rename.  Can
      either just modify the test for the new expectation, or add new files into
      each of the directories to show the weirdness -- or split the test into
      both ones with and without new files within the directories.
  * Removing cached_irrelevant entries from relevant_sources _might_ be okay
    when RELEVANT_LOCATION, but NOT when RELEVANT_CONTENT or RELEVANT_BOTH.
    Not sure if it's okay for RELEVANT_LOCATION either.
       Maybe cached_irrelevant should be cleared whenever -1 !=
       renames->cached_pairs_valid_side instead of also keeping it when
       it has a value matching our current side.
  * Need to really explain 12b and 12c changed behavior better.  Maybe even split
    the testcases

* compare-rebased-hwmon-updates is created with bad trees (not valid sort order)
* Persist cached_irrelevant for next pick?
  * Maybe just ignored cached_pairs (ignore cached_pairs_valid_side of 1 or 2),
    and see if that fixes the bug.  If so, it is due to cached pairs.


* SENTINEL_DIR stuff
  * if culling sources before basename matching:
    * if increment_count() called after handle_early_known_dir_renames(), then
      decrement SENTINEL_DIR count as well

* Stuff to consider with enum relevance
  * I defined the enum in two places
  * Hard-coded 0/1 values in dirs_removed should be documented somehow/somewhere
  * Should write down notes about why cached_pairs is safe (or is it?)
  * Could potentially cull sources before basename matching too

* caching deletes is NOT safe:
  * if path shows up as delete
    * AND dirs_removed[dirname(path)] == 2
    * AND counts shown that first > second + unknown [maybe store value of 3??]
    * THEN DO NOT cache the delete

*** Stuff to investigate:
  * If D/F conflict starts but match_mask on dir, does trivial resolve work?
    Even if the file was renamed into place and has content conflicts?
    resolve_trivial_directory_merge() seems to assume path is handled entirely.

Cleanup stuff:
  * MERGE_DIRECTORY_RENAMES_DEFAULT:
    * differs from MERGE_DIRECTORY_RENAMES_CONFLICT in that it will print an
      informational message about merge.directoryRenames.
      ("directory renames resulted in conflicts, if you'd rather they were
        just automatically resolved, set merge.directoryRenames to true")
  * Attr stuff:
    * pre-merge .gitattributes (assuming no attribute related info), then use
      result in merging other files
  * Output
    * Move diff_warn_rename_limit to join the code doing output of messages
    * print informational message about merge.directoryRenames at same time
    * Make path_msg assert that the path given exists in opt->priv->paths
  * Make merge/ directory
    * output-handling??
    * collect-merge-info
    * rename-detection
    * directory-rename-detection
    * process_entries
    * external-api ?
    * submodule-handling
    * content-merge-handling ? (
  * Make merge_switch_to_result() more versatile:
    * write output to console, to MERGE_OUT, both, or neither
    * update index and working directory, or index only.
      (working directory only makes no sense; at least need an in-memory index)
  * Why does conflict_info need a processed flag?  (merge-recursive holdover?)

Output stuff:
  * GIT_MERGE_VERBOSITY replacement with pipe-separated strings.
    GIT_MERGE_DEBUG? (also, change strings into bitfield upfront, so checks
    can be super cheap).  Then nuke VERBOSE_DEBUG.
    See: string_list_split
  * Write output not just to console but also to some file for user reference
    (much like .git/MERGE_HEAD and friends; maybe .git/MERGE_OUTPUT to go
     along with .git/MERGE_TREE?)

* Overall plan
  X Renames
  X Write the talk
  X Directory renames
  X Implement basic perf ideas
  X Additional Perf testing
  X Micro-optimizations
  X Output
    X write output to merge_result (in field named output, of course)
    X don't need the flush_output() thing
    X use strmap; path -> strbuf, for each path that has a message.
  X Look for test_expect_failure in merge tests of testsuite; fix some
  X Default to histogram diff
  * Path conflict files
  * Check the "Stuff to not forget"
  / Make sure the API is clean/clear
    * make merge-ort have its own options, maybe merge_inmemory_options?
    * make repo part of merge_options_internal?
  / Cleanup of FIXMEs
  * Double check data structures; is anything unnecessary or needing a rename?
  * Correctness testing against lotsa repos
  * Code coverage & valgrind testing
  * Features like --remerge-diff
  * Diff3 improvements

* Stuff to not forget:
  * Path conflict files; also, multiple auxiliary files to add (e.g. for
    mode conflict at a, need a~HEAD, a~MERGE_HEAD, a.path_conflict, or for
    D/F conflict at a, need a~HEAD and a.path_conflict in addition to dir a/)
  * FIXMEs in checkout() (and elsewhere)
  * Do an additional rename-like pass when ignore_case, searching for file
    collisions (or can I just rely on unpack_trees reporting errors?)
  * Avoid string_list_lookup() & string_list_insert() in merge-ort

Path_conflict files:
  * Mode conflict (Directory/Non-Executable/Executable/Submodule/Symlink)
  * Modify/delete (or rename/delete)
  * Rename/rename(1to2)
  * Binary-ish conflict
    * ISREG, but binary
    * symlink edit/edit
    * submodule edit/edit in non-fast-forward ways

  * Maybe also:
    * add/add, rename/add, rename/rename(2to1)
    * rename/add/delete
    * take an add/add onto rename/rename(1to2) or delete/delete onto 2to1

* Important stuff to call out for reviewers to double-check:
  * write_tree() -- yet another place trees are written (builtin/mktree,
    fast-import, cache-tree); is that okay?
  * checkout() (overwrite_ignore? refresh_index?)
  * record_unmerged_index_entries() (cache-tree invalidation?
    state flags correct?  should I avoid ADD_CACHE_JUST_APPEND if
    strmap_size(unmerged) < O(log(opt->repo->index->cache_nr)/3) ?

* Old notes on renames:
  * Rename related information:
    * 1 stage each side: delete/rename (or rename/rename(1to2))
    * 2 stages in source, 1 in dest: typical rename
    * 1 stage in source, 2 in dest: delete/rename/add conflict (or r/r(1to2)/a)
    * 2 stages each side: rename/add
    * (Note that add can be replaced by rename(2to1), just as rename(1to2) can
       replace a delete)

Feature work:
  * git show --remerge-diff[=<pick-commit>] ?  But if multiple commits to show,
    then this doesn't work so well.

* Demo-able stuff
  * Headline
    * "Fearless refactoring" (fast rename detection)
    * "Sparsify & partial clones -- going even further"
  * Behind the scenes
    * Perf
      * pgdev cherry-pick case
      * linux rebase case
      * partial clones improvements, in conjunction with sparse checkouts
    * Correctness
      * avoid false positive/false negative early abort
      * sparse-checkout improvement (avoid unnecessarily dirtying worktree, both
        due to SKIP_WORKTREE stuff, and due to rebase)
      * submodules
      * special cases -- D/F conflicts, etc.
  * new features coming:
    * cherry-pick to a branch which isn't checked out
    * local diff against automerge ('git diff --merge'?)
    * discovery of "evil" merges/cherry-picks/reverts
